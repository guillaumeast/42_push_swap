diff --git a/TODO.md b/TODO.md
index 1357517..4f00307 100644
--- a/TODO.md
+++ b/TODO.md
@@ -1,7 +1,6 @@
-# Tests
+# TODO
 
-- Add chunksize to config (ptr to function to calculate chunksize depending on values_count => square roots and divide versions) (from /2 to /10 ??)
-- Add LIS to CHUNK
+- Use hill climbing instead of bruteforce to find the best chunksize to use
 - Add chunksize reduction to optis
 - Add moves_normalize to delete useless moves: [`PB` -> `PA`], [`RA` -> `RRA`], etc
 
@@ -9,10 +8,6 @@
 
 1. K_SORT
 
-# ALGO_2
-
-1. Test insert_max (always insert the max value of B into A)
-
 # OPTI
 
 1. BACKTRACK
diff --git a/push_swap b/push_swap
deleted file mode 100755
index 8007591..0000000
Binary files a/push_swap and /dev/null differ
diff --git a/src/5_config/config_priv.h b/src/5_config/config_priv.h
index f0b972b..0297b7a 100644
--- a/src/5_config/config_priv.h
+++ b/src/5_config/config_priv.h
@@ -40,7 +40,7 @@
 # define MEDIAN			65536U		/* 00000001 00000000 00000000 */
 # define MEDIAN_COMPAT	131073U		/* 00000111 00000000 00000001 */
 # define LIS			131072U		/* 00000010 00000000 00000000 */
-# define LIS_COMPAT		65537U		/* 00000111 00000000 00000001 */
+# define LIS_COMPAT		458755U		/* 00000111 00000000 00000011 */
 # define SWAP			262144U		/* 00000100 00000000 00000000 */
 # define SWAP_COMPAT	458755U		/* 00000111 00000000 00000011 */
 
diff --git a/src/6_algos/1_sort_three/sort_three.c b/src/6_algos/1_sort_three/sort_three.c
index b955793..c8d91d0 100644
--- a/src/6_algos/1_sort_three/sort_three.c
+++ b/src/6_algos/1_sort_three/sort_three.c
@@ -10,7 +10,6 @@ bool	sort_three(t_state *state, t_config *config)
 		return (true);
 	if (!config->swap || state->b.len < 2)
 		return (sa(&state->a, &state->moves));
-	// NOTE: We don't use opti_swap because it swaps A only if SS is possible (and doesn't swap it at all when LIS is enabled)
 	first_value = stack_get_value(&state->b, 0);
 	second_value = stack_get_value(&state->b, 1);
 	// NOTE: We don't check if B[0] > third_value because sb is "free" when combined with sa so it's ALWAYS better to have greater value higher in B, even if then B[1] < B[2] (because anyway B[0] is already < B[2])
diff --git a/src/6_algos/2_naive/naive.c b/src/6_algos/2_naive/naive.c
index f347d4a..f4dd546 100644
--- a/src/6_algos/2_naive/naive.c
+++ b/src/6_algos/2_naive/naive.c
@@ -5,12 +5,8 @@
 #include "lis.h"
 #include "swap.h"
 
-// TODO [1]: Keep track of first kept/swapped value to stop the loop (to reduce compute complexity)		=> edit lis_push()
-// TODO [2]: Make lis_get_best() take a lis ptr and return a bool (reduce function length by 2 lines)	=> edit lis_push()
-
-static bool	lis_push(t_state *state, t_config *config, t_median *med);
-static bool	lis_swap(t_state *state, t_lis *lis, uint current_value);
-static bool	naive_push(t_state *state, t_config *config, t_median *med);
+static bool	do_lis(t_state *state, t_config *config, t_median *med);
+static bool	do_basic(t_state *state, t_config *config, t_median *med);
 
 bool	naive(t_state *state, t_config *config)
 {
@@ -22,79 +18,59 @@ bool	naive(t_state *state, t_config *config)
 			return (false);
 		return (sort_three(state, config));
 	}
-	median.present = NULL;	// NOTE: in case of premature free from lis_push / naive_push() failure
+	median.present = NULL;	// NOTE: in case of premature free from do_lis / do_basic() failure
 	if (config->median && !median_init(&median, state->a.len))
 		return (false);
 	if (config->lis)
 	{
-		if (!lis_push(state, config, &median))
+		if (!do_lis(state, config, &median))
 			return (median_free(&median), false);
 	}
 	else
-		while (state->a.len > 3)
-			if (!naive_push(state, config, &median))
+		while (state->a.len > 3 && !stack_is_sorted(&state->a))
+			if (!do_basic(state, config, &median))
 				return (median_free(&median), false);
 	if (config->median)
 		median_free(&median);
 	return (sort_three(state, config));
 }
 
-static bool	lis_push(t_state *state, t_config *config, t_median *med)
+static bool	do_lis(t_state *state, t_config *config, t_median *med)
 {
-	t_lis	*lis;
+	t_lis	lis;
 	uint	current_value;
 
-	lis = lis_get_best(&state->a);							// cf TODO [2] at the top of the file
-	if (!lis)
+	if (!lis_compute_best(&state->a, &lis))
 		return (false);
-	while (state->a.len > 3 && !stack_is_sorted(&state->a))	// cf TODO [1] at the top of the file
+	while (state->a.len > 3 && !stack_is_sorted(&state->a))
 	{
 		current_value = stack_get_value(&state->a, 0);
-		if (lis->swap[current_value])
-			lis_swap(state, lis, current_value);
-		else if (lis->keep[current_value])
+		if (lis.swap[current_value])
+		{
+			if (!opti_swap_lis(state, &lis, current_value))
+				return (lis_free(&lis), false);
+		}
+		else if (lis.keep[current_value])
 		{
 			if (!ra(&state->a, 1, &state->moves))
-				return (false);
+				return (lis_free(&lis), false);
 		}
 		else
-			if (!naive_push(state, config, med))
-				return (false);
+			if (!do_basic(state, config, med))
+				return (lis_free(&lis), false);
 	}
 	lis_free(&lis);
 	return (true);
 }
 
-static bool	lis_swap(t_state *state, t_lis *lis, uint current_value)
-{
-	uint 	first_value;
-	uint 	second_value;
-	uint 	third_value;
-
-	lis->swap[current_value] = false;
-	if (state->b.len < 2)
-		return (sa(&state->a, &state->moves));
-	first_value = stack_get_value(&state->b, 0);
-	second_value = stack_get_value(&state->b, 1);
-	if (state->b.len == 2 && first_value < second_value)
-		return (ss(&state->a, &state->b, &state->moves));
-	else if (state->b.len > 2)
-	{
-		third_value = stack_get_value(&state->b, 2);
-		if (first_value < second_value && first_value > third_value)
-			return (ss(&state->a, &state->b, &state->moves));
-	}
-	return (sa(&state->a, &state->moves));
-}
-
-static bool	naive_push(t_state *state, t_config *config, t_median *med)
+static bool	do_basic(t_state *state, t_config *config, t_median *med)
 {
 	if (!pb(&state->a, &state->b, 1, &state->moves))
 		return (false);
 	if (config->median)
 		median_update(med, stack_get_value(&state->b, 0));
 	if (config->swap)
-		if (!opti_swap(state, config))
+		if (!opti_swap_b(state, config))
 			return (false);
 	if (config->median && stack_get_value(&state->b, 0) < med->median)
 		if (!rb(&state->b, 1, &state->moves))
diff --git a/src/6_algos/3_chunk/chunk.c b/src/6_algos/3_chunk/chunk.c
index 9c94e01..7b3950e 100644
--- a/src/6_algos/3_chunk/chunk.c
+++ b/src/6_algos/3_chunk/chunk.c
@@ -1,49 +1,73 @@
 #include "chunk.h"
 #include "sort_three.h"
 #include "moves.h"
+#include "lis.h"
 #include "swap.h"
 #include <stdlib.h>
 
 // TODO [1]: Reduce chunk_size while A is getting smaller ?		=> edit chunk_update()
 
-static bool	chunk_exec(t_state *state, t_config *config, t_chunk *chunk);
+typedef struct s_target
+{
+	size_t	index;
+	uint	val;
+}	t_target;
+
+static bool	do_step(t_state *state, t_config *config, uint value, t_lis *lis);
 static void	chunk_update(t_chunk *chunk);
 
 bool	chunk(t_state *state, t_config *config)
 {
-	while (state->a.len > 3)
+	t_target	target;
+	t_lis		lis;
+
+	if (config->lis && !lis_compute_best(&state->a, &lis))
+		return (false);
+	while (state->a.len > 3 && !stack_is_sorted(&state->a))
 	{
-		if (!chunk_exec(state, config, &config->chunk))
+		target.index = 0;
+		target.val = stack_get_value(&state->a, target.index);
+		while (target.val < config->chunk.min || target.val > config->chunk.max)
+			target.val = stack_get_value(&state->a, ++target.index);
+		if (target.index <= state->a.len / 2)
+		{
+			if (!ra(&state->a, target.index, &state->moves))
+				return (false);
+		}
+		else
+			if (!rra(&state->a, state->a.len - target.index, &state->moves))
+				return (false);
+		if (!do_step(state, config, target.val, &lis))
 			return (false);
 	}
+	if (config->lis)
+		lis_free(&lis);
 	return (sort_three(state, config));
 }
 
-static bool	chunk_exec(t_state *state, t_config *config, t_chunk *chunk)
+static bool	do_step(t_state *state, t_config *config, uint value, t_lis *lis)
 {
-	size_t	target_index;
-	uint	target_value;
-
-	target_index = 0;
-	target_value = stack_get_value(&state->a, target_index);
-	while (target_value < chunk->min || target_value > chunk->max)
-		target_value = stack_get_value(&state->a, ++target_index);
-	if (target_index <= state->a.len / 2)
+	if (config->lis && lis->swap[value])
+	{
+		if (!opti_swap_lis(state, lis, value))
+			return (false);
+	}
+	else if (config->lis && lis->keep[value])
 	{
-		if (!ra(&state->a, target_index, &state->moves))
+		if (!ra(&state->a, 1, &state->moves))
 			return (false);
 	}
 	else
-		if (!rra(&state->a, state->a.len - target_index, &state->moves))
+	{
+		if (!pb(&state->a, &state->b, 1, &state->moves))
 			return (false);
-	if (!pb(&state->a, &state->b, 1, &state->moves))
-		return (false);
-	if (target_value < chunk->median)
-		if (!rb(&state->b, 1, &state->moves))
+		if (value < config->chunk.median)
+			if (!rb(&state->b, 1, &state->moves))
+				return (false);
+		if (config->swap && !opti_swap_b(state, config))
 			return (false);
-	if (config->swap && !opti_swap(state, config))
-		return (false);
-	chunk_update(chunk);
+	}
+	chunk_update(&config->chunk);
 	return (true);
 }
 
diff --git a/src/7_optis/2_lis/lis.c b/src/7_optis/2_lis/lis.c
index 0676802..84622ef 100644
--- a/src/7_optis/2_lis/lis.c
+++ b/src/7_optis/2_lis/lis.c
@@ -3,95 +3,84 @@
 #include "lis_priv.h"
 #include <stdlib.h>
 
-static t_lis	*lis_get(t_stack *stack, size_t start_index);
-static t_lis	*lis_new(t_tail *tail, t_stack *stack);
-static void		lis_compute_swaps(t_lis *lis, t_stack *stack, size_t index);
+static bool	lis_compute(t_lis *lis, t_stack *stack, size_t start_index);
+static bool	lis_init(t_lis *lis, t_tail *tail, t_stack *stack);
+static void	lis_compute_swaps(t_lis *lis, t_stack *stack, size_t index);
 
-t_lis	*lis_get_best(t_stack *stack)
+bool	lis_compute_best(t_stack *stack, t_lis *lis)
 {
 	size_t	start_index;
-	t_lis	*tmp_lis;
-	t_lis	*best_lis;
+	t_lis	tmp_lis;
 	size_t	max_len;
 
-	best_lis = NULL;
 	max_len = 0;
 	start_index = 0;
+	lis->keep = NULL;
+	lis->swap = NULL;
 	while (start_index < stack->len)
 	{
-		tmp_lis = lis_get(stack, start_index);
-		if (!tmp_lis)
-			continue ;
-		else if (tmp_lis->final_len > max_len)
+		if (!lis_compute(&tmp_lis, stack, start_index))
+			return (false);
+		else if (tmp_lis.final_len > max_len)
 		{
-			lis_free(&best_lis);
-			best_lis = tmp_lis;
-			max_len = best_lis->final_len;
+			lis_free(lis);
+			*lis = tmp_lis;
+			max_len = tmp_lis.final_len;
 		}
 		else
 			lis_free(&tmp_lis);
 		start_index++;
 	}
-	return (best_lis);
+	return (true);
 }
 
-static t_lis	*lis_get(t_stack *stack, size_t start_index)
+static bool	lis_compute(t_lis *lis, t_stack *stack, size_t start_index)
 {
-	t_tail	*tail;
-	t_lis	*lis;
+	t_tail	tail;
 	long	index;
 
-	tail = tail_get(stack, start_index);
-	if (!tail)
-		return (NULL);
-	lis = lis_new(tail, stack);
-	if (!lis)
-		return (tail_free(&tail), NULL);
-	index = (long)tail->pos[tail->max_len - 1];
+	if (!tail_compute(&tail, stack, start_index))
+		return (false);
+	if (!lis_init(lis, &tail, stack))
+		return (false);
+	index = (long)tail.pos[tail.max_len - 1];
 	while (index != -1)
 	{
 		lis->keep[stack->data[index]] = true;
 		lis->keep_count++;
-		index = tail->prev[index];
+		index = tail.prev[index];
 	}
 	index = 0;
-	while (index < (int)stack->len)
+	while (index < (long)stack->len)
 	{
 		lis_compute_swaps(lis, stack, (size_t)index);
 		index++;
 	}
 	lis->final_len = lis->keep_count + lis->swap_count;
-	return (lis);
+	return (true);
 }
 
-static t_lis	*lis_new(t_tail *tail, t_stack *stack)
+static bool	lis_init(t_lis *lis, t_tail *tail, t_stack *stack)
 {
-	t_lis	*lis;
-
-	if (!tail || !stack)
-		return (NULL);
-	lis = malloc(sizeof * lis);
-	if (!lis)
-		return (NULL);
 	lis->keep = malloc(stack->len * sizeof * lis->keep);
 	lis->swap = malloc(stack->len * sizeof * lis->keep);
 	if (!lis->keep || !lis->swap)
-		return (lis_free(&lis), NULL);
+		return (lis_free(lis), false);
 	ft_memset(lis->keep, false, stack->len * sizeof * lis->keep);
 	ft_memset(lis->swap, false, stack->len * sizeof * lis->swap);
 	lis->keep_count = 0;
 	lis->swap_count = 0;
 	lis->final_len = 0;
 	lis->start_index = tail->start_index;
-	return (lis);
+	return (true);
 }
 
 static void	lis_compute_swaps(t_lis *lis, t_stack *stack, size_t index)
 {
 	size_t	next_kept_i;
-	uint		current;
-	uint		next;
-	uint		second_next;
+	uint	current;
+	uint	next;
+	uint	second_next;
 
 	current = stack->data[index];
 	next = stack->data[(index + 1) % stack->len];
@@ -110,14 +99,10 @@ static void	lis_compute_swaps(t_lis *lis, t_stack *stack, size_t index)
 	}
 }
 
-void	lis_free(t_lis **lis)
+void	lis_free(t_lis *lis)
 {
-	if (!lis || !*lis)
-		return ;
-	if ((*lis)->keep)
-		free((*lis)->keep);
-	if ((*lis)->swap)
-		free((*lis)->swap);
-	free(*lis);
-	*lis = NULL;
+	if (lis->keep)
+		free(lis->keep);
+	if (lis->swap)
+		free(lis->swap);
 }
diff --git a/src/7_optis/2_lis/lis.h b/src/7_optis/2_lis/lis.h
index 6d8ce62..f929922 100644
--- a/src/7_optis/2_lis/lis.h
+++ b/src/7_optis/2_lis/lis.h
@@ -16,7 +16,7 @@ typedef struct s_lis
 }	t_lis;
 
 // WARNING: only works if stack->offset == 0 !!!
-t_lis	*lis_get_best(t_stack *stack);
-void	lis_free(t_lis **lis);
+bool	lis_compute_best(t_stack *stack, t_lis *lis);
+void	lis_free(t_lis *lis);
 
 #endif
diff --git a/src/7_optis/2_lis/lis_priv.h b/src/7_optis/2_lis/lis_priv.h
index 1c54f1f..c833895 100644
--- a/src/7_optis/2_lis/lis_priv.h
+++ b/src/7_optis/2_lis/lis_priv.h
@@ -13,7 +13,7 @@ typedef struct s_tail
 	long	*prev;
 }	t_tail;
 
-t_tail	*tail_get(t_stack *stack, size_t start_index);
-void	tail_free(t_tail **tail);
+bool	tail_compute(t_tail *tail, t_stack *stack, size_t start_index);
+void	tail_free(t_tail *tail);
 
 #endif
diff --git a/src/7_optis/2_lis/tail.c b/src/7_optis/2_lis/tail.c
index bbdc467..0d2616c 100644
--- a/src/7_optis/2_lis/tail.c
+++ b/src/7_optis/2_lis/tail.c
@@ -2,18 +2,16 @@
 #include "lis_priv.h"
 #include <stdlib.h>
 
-static t_tail	*tail_new(size_t start_index, size_t capacity);
-static void		tail_update(t_tail *tail, uint value, size_t index);
+static bool	tail_init(t_tail *tail, size_t start_index, size_t capacity);
+static void	tail_update(t_tail *tail, uint value, size_t index);
 
-t_tail	*tail_get(t_stack *stack, size_t start_index)
+bool	tail_compute(t_tail *tail, t_stack *stack, size_t start_index)
 {
-	t_tail	*tail;
 	size_t	i;
 	size_t	index;
 
-	tail = tail_new(start_index, stack->len);
-	if (!tail)
-		return (NULL);
+	if (!tail_init(tail, start_index, stack->len))
+		return (false);
 	i = 0;
 	while (i < stack->len)
 	{
@@ -24,13 +22,8 @@ t_tail	*tail_get(t_stack *stack, size_t start_index)
 	return (tail);
 }
 
-static t_tail	*tail_new(size_t start_index, size_t capacity)
+static bool	tail_init(t_tail *tail, size_t start_index, size_t capacity)
 {
-	t_tail	*tail;
-
-	tail = malloc(sizeof * tail);
-	if (!tail)
-		return (NULL);
 	tail->start_index = start_index;
 	tail->array = NULL;
 	tail->pos = NULL;
@@ -40,8 +33,8 @@ static t_tail	*tail_new(size_t start_index, size_t capacity)
 	tail->prev = malloc(capacity * sizeof * tail->prev);
 	if (!tail->array || !tail->pos || !tail->prev)
 	{
-		tail_free(&tail);
-		return (NULL);
+		tail_free(tail);
+		return (false);
 	}
 	ft_memset(tail->pos, -1, capacity * sizeof * tail->pos);
 	ft_memset(tail->prev, -1, capacity * sizeof * tail->prev);
@@ -77,16 +70,12 @@ static void	tail_update(t_tail *tail, uint value, size_t index)
 		tail->prev[index] = -1;
 }
 
-void	tail_free(t_tail **tail)
+void	tail_free(t_tail *tail)
 {
-	if (!tail || !*tail)
-		return ;
-	if ((*tail)->array)
-		free((*tail)->array);
-	if ((*tail)->pos)
-		free((*tail)->pos);
-	if ((*tail)->prev)
-		free((*tail)->prev);
-	free(*tail);
-	*tail = NULL;
+	if (tail->array)
+		free(tail->array);
+	if (tail->pos)
+		free(tail->pos);
+	if (tail->prev)
+		free(tail->prev);
 }
diff --git a/src/7_optis/3_swap/swap.c b/src/7_optis/3_swap/swap.c
index adaef50..8f7f181 100644
--- a/src/7_optis/3_swap/swap.c
+++ b/src/7_optis/3_swap/swap.c
@@ -1,13 +1,11 @@
 #include "swap.h"
 #include "moves.h"
+#include "lis.h"
 
-// TODO[1]: does it really make sens to NOT swap when first_value < third_value ??
-
-bool	opti_swap(t_state *state, t_config *config)
+bool	opti_swap_b(t_state *state, t_config *config)
 {
 	uint	first_value;
 	uint	second_value;
-	uint	third_value;
 
 	if (state->b.len < 2)
 		return (true);
@@ -15,19 +13,34 @@ bool	opti_swap(t_state *state, t_config *config)
 	second_value = stack_get_value(&state->b, 1);
 	if (state->b.len == 2 && first_value > second_value)
 		return (true);
-	else
-	{
-		third_value = stack_get_value(&state->b, 2);
-		if (first_value > second_value || first_value < third_value)	// cf TODO[1] at the top of the file
-			return (true);
-	}
 	if (!config->lis)	// NOTE: swapping A with LIS activated could broken A swaps computed by LIS module
 	{
 		first_value = stack_get_value(&state->a, 0);
 		second_value = stack_get_value(&state->a, 1);
-		third_value = stack_get_value(&state->a, 2);
-		if (first_value > second_value && first_value < third_value)
+		if (first_value > second_value)
 			return (ss(&state->a, &state->b, &state->moves));	
 	}
 	return (sb(&state->b, &state->moves));
 }
+
+bool	opti_swap_lis(t_state *state, t_lis *lis, uint current_value)
+{
+	uint 	first_value;
+	uint 	second_value;
+	uint 	third_value;
+
+	lis->swap[current_value] = false;
+	if (state->b.len < 2)
+		return (sa(&state->a, &state->moves));
+	first_value = stack_get_value(&state->b, 0);
+	second_value = stack_get_value(&state->b, 1);
+	if (state->b.len == 2 && first_value < second_value)
+		return (ss(&state->a, &state->b, &state->moves));
+	else if (state->b.len > 2)
+	{
+		third_value = stack_get_value(&state->b, 2);
+		if (first_value < second_value && first_value > third_value)
+			return (ss(&state->a, &state->b, &state->moves));
+	}
+	return (sa(&state->a, &state->moves));
+}
diff --git a/src/7_optis/3_swap/swap.h b/src/7_optis/3_swap/swap.h
index f2b960c..6745adc 100644
--- a/src/7_optis/3_swap/swap.h
+++ b/src/7_optis/3_swap/swap.h
@@ -3,7 +3,9 @@
 
 # include "state.h"
 # include "config.h"
+# include "lis.h"
 
-bool	opti_swap(t_state *state, t_config *config);
+bool	opti_swap_b(t_state *state, t_config *config);
+bool	opti_swap_lis(t_state *state, t_lis *lis, uint current_value);
 
 #endif
